<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Страница 4</title>
  <link rel="stylesheet" href="../styles/index.css">
</head>
<body>
<main>
  <article>
    <p>С помощью объекта bsObj мы можем вызвать функцию findAll, чтобы извлечь список имен
      собственных. Их находят путем отбора текста, находящегося внутри тегов &ltspan class="green"&gt&lt/span&gt.
      В общем виде запрос выглядит следующим образом: bsObj.findAll(tagName,
      tagAttributes). Он позволяет получить список всех тегов с указанным именем и атрибутами. Функция
      findAll возвращает теги с их содержимым. Наконец функция name.get_text() отделяет контент от
      тегов, и печатает только имена.</p>

    <p>На самом деле функция findAll имеет больше аргументов:</p>

    <code>
      findAll(tag, attributes, recursive, text, limit, keywords)
    </code>

    <p>
      А аргументами tag и attributes мы только что познакомились. Аргумент recursive является булевым
      значением. По умолчанию он равен True и функция findAll исследует элементы на всю глубину
      вложенности тегов. Если установлено значение False, то будут исследованы только теги верхнего
      (первого) уровня. Аргумент text ищет совпадения, руководствуясь текстовым содержимым тегов, а не
      свойствами самих тегов. Например, код:
    </p>

    <code>
      nameList = bsObj.findAll(text="the prince")
      print(len(nameList))
    </code>

    <p>вернет число вхождений фразы "the prince" в текст (7).</p>

    <p>
      Аргумент limit позволяет ограничить извлечение первыми x элементами со страницы. Аргумент
      keyword позволяет вам выбрать теги, содержащие конкретный атрибут. Например,
    </p>

    <code>
      allText = bsObj.findAll(id="text")
      print(allText[0].get_text())
    </code>

    <p>
      Помимо двух основных объектов библиотеки BeautifulSoup (объекты BeautifulSoup, например bsObj и
      объекты Tag, возвращаемые функцией findAll) существуют объекты NavigableString: используются для
      представления текста внутри тегов, а не самих тегов, и объект Comment: используются для поиска
      HTML-комментариев в тегах комментариев &lt!-как, например, этот--&gt
    </p>

    <p>
      <i>Навигация по дереву синтаксического разбора.</i> Функция findAll осуществляет поиск тегов по их
      имени и атрибуту. Но что, если вам нужно найти тег, основываясь на его месторасположении в
      документе? Навигация вглубь осуществляется просто:
    </p>

    <code>
      bsObj.tag.subTag.anotherSubTag
    </code>

    <p>
      В библиотеке BeautifulSoup существует различие между дочерними элементами и элементамипотомками: дочерние теги всегда на один уровень ниже родительского тега, в то время как тегипотомки могут быть ниже родительского тега, располагаясь на любом уровне. Например,
      bsObj.body.h1 выбирает первый тег h1, который является потомком тега body. Она не найдет теги,
      расположенные вне body. Аналогично bsObj.div.findAll("img") найдет первый тег div в документе, а
      затем извлечет все теги img, которые являются потомками тега div.
    </p>

    <p>
      Если вы хотите извлечь только дочерние теги, используйте тег .children:
    </p>

    <code>
      from urilib.request import urlopen
      from bs4 import BeautifulSoup
      html = urlopen("http://www.pythonscraping.com/pages/page3.html")
      bsObj = BeautifulSoup(html, "html.parser")
      for child in bsObj.find("table",{"id":"giftList"}).children:
      &nbsp;&nbsp;print(child)
    </code>

    <p>
      Этот код выводит список строк с названиями продуктов таблицы giftList. Если бы вы написали его,
      используя функцию descendants() вместо функции children(), в таблице было бы найдено и
      напечатано около двух десятков тегов, в том числе теги img, теги span и отдельные теги td.
    </p>
    <p>
      Функции next_siblings(), previous_ siblings упрощают сбор данных из таблиц, а для работы с
      родительскими тегами служит функция parents().
    </p>
    <p>Регулярные выражения – это быстрый способ представления наборов правил. Например,</p>
  </article>
</main>
</body>
</html>